"use strict";(self.webpackChunkoverreact_docs=self.webpackChunkoverreact_docs||[]).push([[6210],{962:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>a,default:()=>c,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var s=t(5893),r=t(1151);const o={},a="Game Loop",i={id:"guides/game-loop",title:"Game Loop",description:"Overview",source:"@site/docs/guides/game-loop.md",sourceDirName:"guides",slug:"/guides/game-loop",permalink:"/docs/guides/game-loop",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Getting Started",permalink:"/docs/getting-started"},next:{title:"Properties",permalink:"/docs/guides/properties"}},h={},l=[{value:"Overview",id:"overview",level:2},{value:"An example",id:"an-example",level:2},{value:"The update phase",id:"the-update-phase",level:3},{value:"The render phase",id:"the-render-phase",level:3},{value:"Under the hood",id:"under-the-hood",level:2},{value:"See also",id:"see-also",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"game-loop",children:"Game Loop"}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"React takes care of a lot for us. It provides a component lifecycle which ensures that when application state changes, the components that own that state get rerendered, as a result of which the DOM is updated."}),"\n",(0,s.jsx)(n.p,{children:"This works well for general web app development, where a change in state causes a data table to change, or a transition to a different screen, but for games we need the consistency and guarantee for running code every frame, 60 times per second."}),"\n",(0,s.jsxs)(n.p,{children:["One thing all game engines have in common, is how they achieve this. Typically it is referred to as the ",(0,s.jsx)(n.strong,{children:'"game loop"'}),', or "core loop", and it consists of two things:']}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The update phase, which is responsible for updating the state of the entire game, taking into account the amount of time that has elapsed since the previous frame."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The render phase, which is responsible for rendering the next image that is sent to the screen, taking into account everything that just changed in the game state."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Let's take a look at an example."}),"\n",(0,s.jsx)(n.p,{children:'Image a simple platform game. In it, the player has a position, represented as coordinates. The player also has a velocity, describing the direction and speed with which the player is currently moving. Each frame, in the "update" phase we update the set a new position for the player, based on their current position and their velocity. Then, once that is done, we render the player to the screen in their new location.'}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["In ",(0,s.jsx)(n.em,{children:"Overreact"})," the ",(0,s.jsx)(n.a,{href:"../components/engine",children:(0,s.jsx)(n.code,{children:"Engine"})})," component initializes the game loop for us."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"an-example",children:"An example"}),"\n",(0,s.jsx)(n.p,{children:"Let's create a component that renders a multicolored square on screen."}),"\n",(0,s.jsx)(n.h3,{id:"the-update-phase",children:"The update phase"}),"\n",(0,s.jsxs)(n.p,{children:["Our component outputs an empty div, with no styles, and no classes. It has a ",(0,s.jsx)(n.code,{children:"hue"})," ref, and each frame the hue value is increased by a small amount. If we were to run this we'd see nothing, because we aren't 'rendering' anything yet."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const MyComponent = () => {\n  const ref = useRef<HTMLDivElement>(null);\n  const hue = useRef(0);\n\n  useUpdate((delta) => {\n    hue.current = hue.current + (delta * 0.1);\n  });\n\n  return <div ref={ref} style={{ width: '100px', height: '100px' }} />;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"the-render-phase",children:"The render phase"}),"\n",(0,s.jsxs)(n.p,{children:["Let's add a render function, which updates the background color of the element, based on the current ",(0,s.jsx)(n.code,{children:"hue"})," value."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const MyComponent = () => {\n  const ref = useRef<HTMLDivElement>(null);\n  const hue = useRef(0);\n\n  useUpdate((delta) => {\n    hue.current = hue.current + (delta * 0.1);\n  });\n\n  // highlight-start\n  useRender(() => {\n    ref.style.background = `hsl(${hue.current}deg 100% 50%)`;\n  });\n  // highlight-end\n\n  return <div ref={ref} style={{ width: '100px', height: '100px' }} />;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"That's better, now we see the square, cycling gradually through all of the colors of the rainbow."}),"\n",(0,s.jsx)(n.h2,{id:"under-the-hood",children:"Under the hood"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"Overreact"})," game loop uses ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame",children:(0,s.jsx)(n.code,{children:"requestAnimationFrame"})})," to request that the browser runs one iteration of the loop each time it is ready to draw to the screen. Here's a simplified version of what it looks like:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"let previous = 0;\n\nfunction loop(next) {\n  const delta = next - previous;\n  previous = next;\n\n  update(delta);\n  render();\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"see-also",children:"See also"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["MDN has an excellent article on game loops: ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Games/Anatomy",children:"https://developer.mozilla.org/en-US/docs/Games/Anatomy"})]}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>i,a:()=>a});var s=t(7294);const r={},o=s.createContext(r);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);